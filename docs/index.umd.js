(function(f,c){typeof exports=="object"&&typeof module<"u"?c(exports):typeof define=="function"&&define.amd?define(["exports"],c):(f=typeof globalThis<"u"?globalThis:f||self,c(f.stretto={}))})(this,(function(f){"use strict";var v=Object.defineProperty;var N=(f,c,T)=>c in f?v(f,c,{enumerable:!0,configurable:!0,writable:!0,value:T}):f[c]=T;var D=(f,c,T)=>N(f,typeof c!="symbol"?c+"":c,T);const m=new Uint8Array([100,97,116,97,58]),p=10,g=16*1024*1024;function A(a){let t=new Uint8Array(65536),e=0;const l=new TextDecoder;return new TransformStream({transform(r,i){if(e+r.length>t.length){if(t.length>=g){i.error(new Error(`SSE buffer size exceeded safety limit of ${g} bytes.`));return}const o=Math.max(t.length*2,e+r.length),u=new Uint8Array(Math.min(o,g));u.set(t.subarray(0,e)),t=u}t.set(r,e),e+=r.length;let s=0;for(;;){const o=w(t,s,e);if(o===-1)break;const u=t.subarray(s,o);d(u,i),s=o+2}s>0&&(t.copyWithin(0,s,e),e-=s)},flush(r){e>0&&d(t.subarray(0,e),r)}});function w(r,i,s){for(let o=i;o<s-1;o++)if(r[o]===p&&r[o+1]===p)return o;return-1}function d(r,i){if(r.length===0)return;let s=0;const o=[];for(let n=0;n<r.length;n++)if(r[n]===p){const y=r.subarray(s,n);b(y,m)&&o.push(h(y)),s=n+1}const u=r.subarray(s);if(b(u,m)&&o.push(h(u)),o.length===0)return;const E=o.join(`
`);if(E!=="[DONE]")try{i.enqueue(JSON.parse(E))}catch(n){if(a.strictJson){const y=n instanceof Error?n:void 0;i.error(new TypeError(`Invalid JSON in SSE stream: "${E}"`,{cause:y}))}}}function h(r){let i=m.length;return r.length>i&&r[i]===32&&i++,l.decode(r.subarray(i))}function b(r,i){if(i.length>r.length)return!1;for(let s=0;s<i.length;s++)if(r[s]!==i[s])return!1;return!0}}function O(a,t){let e=!1;return Object.defineProperty(a,Symbol.asyncIterator,{value:async function*(){if(e)throw new Error("Body has already been consumed. Use response.clone() for multiple iterations.");if(!a.body)return;if(e=!0,!t.stream){yield await a.json();return}const l=t.parser===void 0?A({strictJson:t.strictJson??!0}):t.parser,d=(l===null?a.body:a.body.pipeThrough(l)).getReader();try{for(;;){const{done:h,value:b}=await d.read();if(h)break;yield b}}finally{d.releaseLock()}},writable:!1,configurable:!0}),a}const _=a=>new Promise(t=>setTimeout(t,a)),F=100,M=5e3,R=2,S=.5,I=a=>{const t=F*Math.pow(R,a-1);return Math.min(M,t)*(1-S+Math.random()*S)},U=a=>a.status>=500&&a.status<600;function x(a,t=0){if(t<=0)return a??new AbortController().signal;const e=AbortSignal.timeout(t);return a?AbortSignal.any([a,e]):e}class L extends Error{constructor(e,l){super(e);D(this,"response");this.name="HTTPError",this.response=l}}async function P(a,t={}){const{retries:e=3,timeout:l=5e3,backoffStrategy:w=I,retryOn:d=U,stream:h=!1,strictJson:b=!0,parser:r,signal:i,...s}=t;if(e<0||l<0)throw new RangeError("Retries and timeout must be non-negative.");let o=0,u;for(;o<=e;){const E=x(i,l);if(E.aborted)throw E.reason??new DOMException("Request aborted","AbortError");try{const n=await fetch(a,{...s,signal:E});if(n.ok)return O(n,{stream:h,strictJson:b,parser:r});const y=new L(`Request failed with status ${n.status}: ${n.statusText}`,n);if(o>=e||!d(n))throw y;u=y}catch(n){if(u=n,n instanceof DOMException&&(n.name==="AbortError"||n.name==="TimeoutError")||n instanceof TypeError&&n.message.includes("fetch"))throw n;if(o>=e)break}o++,o<=e&&await _(w(o-1))}throw u??new DOMException(`Request failed after ${e+1} attempts.`,"AbortError")}f.default=P,f.sseParser=A,Object.defineProperties(f,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
