(function(m,w){typeof exports=="object"&&typeof module<"u"?w(exports):typeof define=="function"&&define.amd?define(["exports"],w):(m=typeof globalThis<"u"?globalThis:m||self,w(m.stretto={}))})(this,(function(m){"use strict";var H=Object.defineProperty;var K=(m,w,L)=>w in m?H(m,w,{enumerable:!0,configurable:!0,writable:!0,value:L}):m[w]=L;var P=(m,w,L)=>K(m,typeof w!="symbol"?w+"":w,L);new TextDecoder;class O extends Error{constructor(t,d){super(t);P(this,"response");this.name="HTTPError",this.response=d}}class x{constructor(e){P(this,"buffer");P(this,"writePos",0);P(this,"readPos",0);P(this,"_occupied",0);const t=Math.pow(2,Math.ceil(Math.log2(e)));this.buffer=new Uint8Array(t)}get size(){return this.buffer.length}get occupied(){return this._occupied}get available(){return this.size-this._occupied}getByteAt(e){return this.buffer[e&this.size-1]}getBuffer(){return this.buffer}get currentReadPos(){return this.readPos}write(e){if(e.length>this.available)return!1;const t=Math.min(e.length,this.size-this.writePos);return t>0&&this.buffer.set(e.subarray(0,t),this.writePos),e.length-t>0&&this.buffer.set(e.subarray(t),0),this.writePos=this.writePos+e.length&this.size-1,this._occupied+=e.length,!0}getView(e,t){if(t===0)return new Uint8Array(0);const d=this.size-1,u=this.readPos+e&d;if(u+t<=this.size)return this.buffer.subarray(u,u+t);const l=new Uint8Array(t),c=this.size-u;return l.set(this.buffer.subarray(u,u+c),0),l.set(this.buffer.subarray(0,t-c),c),l}consume(e){if(e>this._occupied)throw new Error("Cannot consume more than occupied space");this.readPos=this.readPos+e&this.size-1,this._occupied-=e}peekByte(e){if(e>=this._occupied)throw new Error("Offset beyond occupied data");return this.getByteAt(this.readPos+e)}findPattern(e,t){const d=Math.min(t??this._occupied,this._occupied-e.length+1);for(let u=0;u<=d-e.length;u++){let l=!0;for(let c=0;c<e.length;c++)if(this.peekByte(u+c)!==e[c]){l=!1;break}if(l)return u}return-1}}function U(o={}){const{strictJson:e=!0,includeEventAndId:t=!1,pureJson:d=!1,minBufferSize:u=65536,maxBufferSize:l=1024*1024}=o;if(u<0||l<0)throw new RangeError("Buffer sizes must be non-negative");if(u>l)throw new RangeError("minBufferSize cannot exceed maxBufferSize");const c=Math.max(u,65536),a=new x(c),D=[10,10],F=[13,10,13,10],S=new TextDecoder,_=[100,97,116,97,58],R=[101,118,101,110,116,58],T=[105,100,58],E=10,B=13;function g(){let i=a.findPattern(D);return i!==-1?{offset:i,delimiterLength:2}:(i=a.findPattern(F),i!==-1?{offset:i,delimiterLength:4}:null)}function M(i){const f=[];let n,s,r=0;for(;r<i;){let y=r;for(;y<i&&a.peekByte(y)!==E;)y++;const b=y-r;if(b===0){r=y+1;continue}const p=b>0&&a.peekByte(y-1)===B?b-1:b;if(p>=5&&v(r,_)){let h=r+5;a.peekByte(h)===32&&h++;const A=r+p-h;A>0&&f.push(a.getView(h,A))}else if(t){if(p>=6&&v(r,R)){let h=r+6;a.peekByte(h)===32&&h++;const A=a.getView(h,r+p-h);n=S.decode(A)}else if(p>=3&&v(r,T)){let h=r+3;a.peekByte(h)===32&&h++;const A=a.getView(h,r+p-h);n=S.decode(A)}}r=y+1}return{data:f,event:n,id:s}}function v(i,f){for(let n=0;n<f.length;n++)if(a.peekByte(i+n)!==f[n])return!1;return!0}function I(i){if(i.length===0)return"";if(i.length===1)return S.decode(i[0]);let f=0;for(const r of i)f+=r.length;f+=i.length-1;const n=new Uint8Array(f);let s=0;for(let r=0;r<i.length;r++)r>0&&(n[s++]=E),n.set(i[r],s),s+=i[r].length;return S.decode(n)}return new TransformStream({transform(i,f){try{if(!a.write(i)){f.error(new Error(`Buffer overflow: chunk size ${i.length} exceeds available space ${a.available}`));return}for(;a.occupied>0;){const n=g();if(!n)break;const s=n.offset;if(s===0){a.consume(n.delimiterLength);continue}try{const r=M(s);if(r.data.length>0){const y=I(r.data);if(y==="[DONE]"){a.consume(s+n.delimiterLength);continue}let b;if(d)b=JSON.parse(y);else try{b=JSON.parse(y)}catch(p){if(e)throw p;b=y}t?f.enqueue({data:b,event:r.event,id:r.id}):f.enqueue(b)}}catch(r){if(e){f.error(r);return}}a.consume(s+n.delimiterLength)}}catch(n){f.error(n)}},flush(i){if(a.occupied>0)try{const f=M(a.occupied);if(f.data.length>0){const n=I(f.data);if(n!=="[DONE]"){let s;if(d)s=JSON.parse(n),i.enqueue(s);else{try{s=JSON.parse(n)}catch(r){if(e){i.error(new Error(`Failed to parse remaining JSON data: ${n}`,{cause:r}));return}s=n}t?i.enqueue({data:s,event:f.event,id:f.id}):i.enqueue(s)}}}else if(!e){const n=a.getView(0,a.occupied),s=S.decode(n).trim();if(s.length>0&&s!=="[DONE]")if(s.startsWith("{")||s.startsWith("[")||s.startsWith('"'))try{const r=JSON.parse(s);i.enqueue(r)}catch{i.enqueue(s)}else i.enqueue(s)}}catch(f){e&&i.error(f),console.warn("SSE flush warning:",f)}}})}function N(o,e){let t=!1;return Object.defineProperty(o,Symbol.asyncIterator,{value:async function*(){if(t)throw new Error("Body has already been consumed. Use response.clone() for multiple iterations.");if(!o.body)return;if(t=!0,!e.stream)return o;const d=e.parser===void 0?U({strictJson:e.strictJson??!0,includeEventAndId:e.includeEventAndId??!1,minBufferSize:e.minBufferSize??1024,maxBufferSize:e.maxBufferSize??1024*4}):e.parser,l=(d===null?o.body:o.body.pipeThrough(d)).getReader();try{for(;;){const{done:c,value:a}=await l.read();if(c)break;yield a}}catch(c){throw e.onStreamError&&e.onStreamError(c),c}finally{l.releaseLock()}},writable:!1,configurable:!0}),o}const J=o=>new Promise(e=>setTimeout(e,o)),q=100,k=5e3,V=2,z=.5,$=o=>{const e=q*Math.pow(V,o);return Math.min(k,e)*(1-z+Math.random()*z)},j=o=>o.status>=500&&o.status<600;function X(o,e=0){if(e<=0)return o??new AbortController().signal;const t=AbortSignal.timeout(e);return o?AbortSignal.any([o,t]):t}async function C(o,e={}){const{retries:t=3,timeout:d=5e3,backoffStrategy:u=$,retryOn:l=j,stream:c=!1,strictJson:a=!0,minBufferSize:D=1024,maxBufferSize:F=8*1024,parser:S,signal:_,...R}=e;if(t<0||d<0)throw new RangeError("Retries and timeout must be non-negative.");let T;for(let E=0;E<=t;E++){const B=X(_,d);if(B.aborted)throw B.reason??new DOMException("Request aborted before fetch","AbortError");try{const g=await fetch(o,{...R,signal:B});if(g.ok)return N(g,{stream:c,strictJson:a,parser:S});if(T=new O(`Request failed with status ${g.status}: ${g.statusText}`,g),!l(g))throw T}catch(g){if(T=g,g instanceof DOMException&&(g.name==="AbortError"||g.name==="TimeoutError"))throw T}if(E>=t)break;E<t&&!B.aborted&&await J(u(E))}throw T??new Error(`Request failed after ${t+1} attempts.`)}m.HTTPError=O,m.default=C,Object.defineProperties(m,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
